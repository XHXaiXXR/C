	在C++中我们通常通过typeid （是一个函数）来提取； 但是只能获得类型，并不能用来声明变量；
 于是就产生了类型萃取来完成这一功能；

	POD类型萃取： plain old data 平凡类型（无关痛痒的类型）--基本类型指在C++ 中与 C兼容的类型，可以按照 C 的方式处理

	我们知道其实在库里的string 对象中有两个成员_buf和_ptr; 那么这两个成员有什么用呢？_buf我们默认的有16个字节的空间，挡string的字符串小于16个的时候一般存储在_buf中，当字符串长度比较长的时候，我们一般就用到了_ptr， 这个_ptr是一个指针，它可以指向这个字符串的空间，这样，我们string 类就可以 用这四个字节的空间去存储字符串的地址；
 但是，我们这里用了memcpy函数来进行拷贝，那么，问题来了， memcpy是内存拷贝，直接拷贝内存，于是乎，就将这个_ptr 进行了一次拷贝，然后释放掉原来的_ptr； 是不是有问题了，  memcpy进行拷贝之后，我的两个_ptr都指向同一块空间；没有引用计数器的情况下，你释放掉一个_ptr，那就有问题了吧！   这就相当于浅拷贝的问题！

	仔细看，我们在用循环解决这个问题的时候循环内部是 dest[i] = src[i];这里调用的是成员赋值操作符，如果是string类的成员，那么我们就调用的是string类的赋值操作符；而我们库里的string类已经解决这个问题

	所以，如果传进来的是内置类型，我们就用mencpy或者menmove，如果不是内置类型的话，我们就用赋值拷贝的方式一个一个的去赋值。